package zip

import (
	"errors"
	"os"
	"path/filepath"
	"reflect"
	"sort"
	"testing"
	"time"

	"github.com/hikobae/aferoutil"
	"github.com/spf13/afero"
)

type zipTest struct {
	dstDir string
	name   string
	mode   os.FileMode
	data   []byte
	files  []zipTestFile
}

type zipTestFile struct {
	name     string
	modified time.Time
	content  []byte
}

var zipTests = []zipTest{
	{
		dstDir: "xyz",
		name:   "abc.zip",
		mode:   0644,
		data:   []byte{0x50, 0x4b, 0x3, 0x4, 0xa, 0x0, 0x0, 0x0, 0x0, 0x0, 0xd3, 0x41, 0x7e, 0x50, 0x28, 0x41, 0x46, 0x0, 0xc, 0x0, 0x0, 0x0, 0xc, 0x0, 0x0, 0x0, 0x7, 0x0, 0x0, 0x0, 0x61, 0x62, 0x63, 0x2e, 0x74, 0x78, 0x74, 0x74, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20, 0x74, 0x65, 0x73, 0x74, 0x50, 0x4b, 0x1, 0x2, 0x3f, 0x0, 0xa, 0x0, 0x0, 0x0, 0x0, 0x0, 0xd3, 0x41, 0x7e, 0x50, 0x28, 0x41, 0x46, 0x0, 0xc, 0x0, 0x0, 0x0, 0xc, 0x0, 0x0, 0x0, 0x7, 0x0, 0x24, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x61, 0x62, 0x63, 0x2e, 0x74, 0x78, 0x74, 0xa, 0x0, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x18, 0x0, 0x57, 0x88, 0xf0, 0xd0, 0x1f, 0x6, 0xd6, 0x1, 0x57, 0x88, 0xf0, 0xd0, 0x1f, 0x6, 0xd6, 0x1, 0xaf, 0xfb, 0xd1, 0xcd, 0x1f, 0x6, 0xd6, 0x1, 0x50, 0x4b, 0x5, 0x6, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x1, 0x0, 0x59, 0x0, 0x0, 0x0, 0x31, 0x0, 0x0, 0x0, 0x0, 0x0},
		files: []zipTestFile{
			zipTestFile{
				name:     "abc.txt",
				modified: time.Date(2020, 3, 30, 8, 14, 37, 318562300, time.FixedZone("JST", 9*60*60)),
				content:  []byte("this is test"),
			},
		},
	},
}

func TestUnarchive(t *testing.T) {
	fs := afero.NewMemMapFs()
	for _, tc := range zipTests {
		testUnarchiveFile(t, fs, tc)
	}
}

func testUnarchiveFile(t *testing.T, fs afero.Fs, tc zipTest) {
	if err := afero.WriteFile(fs, tc.name, tc.data, tc.mode); err != nil {
		t.Fatalf("expected nil, but %v", err)
	}
	defer func() {
		if err := fs.Remove(tc.name); err != nil {
			t.Errorf("expected nil, but %v", err)
		}
	}()

	if err := Unarchive(fs, tc.name, tc.dstDir); err != nil {
		t.Fatalf("%q: expected nil, but %v", tc.name, err)
	}
	defer func() {
		if err := fs.RemoveAll(tc.dstDir); err != nil {
			t.Errorf("expected nil, but %v", err)
		}
	}()

	files, err := aferoutil.ListFiles(fs, tc.dstDir)
	if err != nil {
		t.Fatalf("expected nil, but %v", err)
	}
	if len(files) != len(tc.files) {
		t.Fatalf("file count=%d, want=%d", len(files), len(tc.files))
	}

	for _, f := range tc.files {
		p := filepath.Join(tc.dstDir, f.name)
		exists, err := afero.Exists(fs, p)
		if !exists {
			t.Fatalf("%q not exists", p)
		}
		if err != nil {
			t.Fatalf("expected nil, but %v", err)
		}

		fi, err := fs.Stat(p)
		if err != nil {
			t.Fatalf("expected nil, but %v", err)
		}
		if !fi.ModTime().Equal(f.modified) {
			t.Errorf("%q: modtime=%v, want=%v", p, fi.ModTime(), f.modified)
		}

		content, err := afero.ReadFile(fs, p)
		if err != nil {
			t.Fatalf("expected nil, but %v", err)
		}
		if len(content) != len(f.content) {
			t.Fatalf("%s: len=%d, want=%d", p, len(content), len(f.content))
		}
		for i, b := range content {
			if b != f.content[i] {
				t.Errorf("%s: content[%d]=%q, want=%q", p, i, b, f.content[i])
			}
		}
	}
}

type testCaseUnarchiveDir struct {
	data  []byte
	files []string
}

var testcases = []testCaseUnarchiveDir{
	{
		[]byte{0x50, 0x4b, 0x3, 0x4, 0x14, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9d, 0x15, 0x7d, 0x50, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x4, 0x0, 0x0, 0x0, 0x78, 0x79, 0x7a, 0x2f, 0x50, 0x4b, 0x1, 0x2, 0x3f, 0x0, 0x14, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9d, 0x15, 0x7d, 0x50, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x4, 0x0, 0x24, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x78, 0x79, 0x7a, 0x2f, 0xa, 0x0, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x18, 0x0, 0xaf, 0xcf, 0x26, 0x98, 0x28, 0x5, 0xd6, 0x1, 0xaf, 0xcf, 0x26, 0x98, 0x28, 0x5, 0xd6, 0x1, 0xaf, 0xcf, 0x26, 0x98, 0x28, 0x5, 0xd6, 0x1, 0x50, 0x4b, 0x5, 0x6, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x1, 0x0, 0x56, 0x0, 0x0, 0x0, 0x22, 0x0, 0x0, 0x0, 0x0, 0x0},
		[]string{"xyz/"},
	},
	{
		[]byte{0x50, 0x4b, 0x3, 0x4, 0xa, 0x0, 0x0, 0x0, 0x0, 0x0, 0x29, 0x3, 0x7d, 0x50, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7, 0x0, 0x0, 0x0, 0x64, 0x65, 0x66, 0x2e, 0x74, 0x78, 0x74, 0x50, 0x4b, 0x3, 0x4, 0x14, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0x3, 0x7d, 0x50, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xa, 0x0, 0x0, 0x0, 0x65, 0x6d, 0x70, 0x74, 0x79, 0x5f, 0x64, 0x69, 0x72, 0x2f, 0x50, 0x4b, 0x3, 0x4, 0x14, 0x0, 0x0, 0x0, 0x0, 0x0, 0x47, 0x3, 0x7d, 0x50, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7, 0x0, 0x0, 0x0, 0x73, 0x75, 0x62, 0x64, 0x69, 0x72, 0x2f, 0x50, 0x4b, 0x3, 0x4, 0x14, 0x0, 0x0, 0x0, 0x0, 0x0, 0x4c, 0x3, 0x7d, 0x50, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xf, 0x0, 0x0, 0x0, 0x73, 0x75, 0x62, 0x64, 0x69, 0x72, 0x2f, 0x73, 0x75, 0x62, 0x64, 0x69, 0x72, 0x32, 0x2f, 0x50, 0x4b, 0x3, 0x4, 0xa, 0x0, 0x0, 0x0, 0x0, 0x0, 0x4b, 0x3, 0x7d, 0x50, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x14, 0x0, 0x0, 0x0, 0x73, 0x75, 0x62, 0x64, 0x69, 0x72, 0x2f, 0x73, 0x75, 0x62, 0x64, 0x69, 0x72, 0x32, 0x2f, 0x79, 0x2e, 0x74, 0x78, 0x74, 0x50, 0x4b, 0x3, 0x4, 0xa, 0x0, 0x0, 0x0, 0x0, 0x0, 0x46, 0x3, 0x7d, 0x50, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xc, 0x0, 0x0, 0x0, 0x73, 0x75, 0x62, 0x64, 0x69, 0x72, 0x2f, 0x78, 0x2e, 0x74, 0x78, 0x74, 0x50, 0x4b, 0x3, 0x4, 0xa, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2f, 0x3, 0x7d, 0x50, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7, 0x0, 0x0, 0x0, 0x78, 0x79, 0x7a, 0x2e, 0x74, 0x78, 0x74, 0x50, 0x4b, 0x1, 0x2, 0x3f, 0x0, 0xa, 0x0, 0x0, 0x0, 0x0, 0x0, 0x29, 0x3, 0x7d, 0x50, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7, 0x0, 0x24, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x64, 0x65, 0x66, 0x2e, 0x74, 0x78, 0x74, 0xa, 0x0, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x18, 0x0, 0xed, 0xbc, 0x7e, 0x15, 0x15, 0x5, 0xd6, 0x1, 0xed, 0xbc, 0x7e, 0x15, 0x15, 0x5, 0xd6, 0x1, 0xed, 0xbc, 0x7e, 0x15, 0x15, 0x5, 0xd6, 0x1, 0x50, 0x4b, 0x1, 0x2, 0x3f, 0x0, 0x14, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0x3, 0x7d, 0x50, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xa, 0x0, 0x24, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x10, 0x0, 0x0, 0x0, 0x25, 0x0, 0x0, 0x0, 0x65, 0x6d, 0x70, 0x74, 0x79, 0x5f, 0x64, 0x69, 0x72, 0x2f, 0xa, 0x0, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x18, 0x0, 0x2f, 0xe0, 0x76, 0x20, 0x15, 0x5, 0xd6, 0x1, 0x2f, 0xe0, 0x76, 0x20, 0x15, 0x5, 0xd6, 0x1, 0x2f, 0xe0, 0x76, 0x20, 0x15, 0x5, 0xd6, 0x1, 0x50, 0x4b, 0x1, 0x2, 0x3f, 0x0, 0x14, 0x0, 0x0, 0x0, 0x0, 0x0, 0x47, 0x3, 0x7d, 0x50, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7, 0x0, 0x24, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x10, 0x0, 0x0, 0x0, 0x4d, 0x0, 0x0, 0x0, 0x73, 0x75, 0x62, 0x64, 0x69, 0x72, 0x2f, 0xa, 0x0, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x18, 0x0, 0x6d, 0xcf, 0xd9, 0x36, 0x15, 0x5, 0xd6, 0x1, 0x6d, 0xcf, 0xd9, 0x36, 0x15, 0x5, 0xd6, 0x1, 0xd6, 0x34, 0x27, 0x26, 0x15, 0x5, 0xd6, 0x1, 0x50, 0x4b, 0x1, 0x2, 0x3f, 0x0, 0x14, 0x0, 0x0, 0x0, 0x0, 0x0, 0x4c, 0x3, 0x7d, 0x50, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xf, 0x0, 0x24, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x10, 0x0, 0x0, 0x0, 0x72, 0x0, 0x0, 0x0, 0x73, 0x75, 0x62, 0x64, 0x69, 0x72, 0x2f, 0x73, 0x75, 0x62, 0x64, 0x69, 0x72, 0x32, 0x2f, 0xa, 0x0, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x18, 0x0, 0x4d, 0x9a, 0x78, 0x3c, 0x15, 0x5, 0xd6, 0x1, 0x4d, 0x9a, 0x78, 0x3c, 0x15, 0x5, 0xd6, 0x1, 0x4e, 0x74, 0xf3, 0x29, 0x15, 0x5, 0xd6, 0x1, 0x50, 0x4b, 0x1, 0x2, 0x3f, 0x0, 0xa, 0x0, 0x0, 0x0, 0x0, 0x0, 0x4b, 0x3, 0x7d, 0x50, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x14, 0x0, 0x24, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x20, 0x0, 0x0, 0x0, 0x9f, 0x0, 0x0, 0x0, 0x73, 0x75, 0x62, 0x64, 0x69, 0x72, 0x2f, 0x73, 0x75, 0x62, 0x64, 0x69, 0x72, 0x32, 0x2f, 0x79, 0x2e, 0x74, 0x78, 0x74, 0xa, 0x0, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x18, 0x0, 0x6f, 0x94, 0xf3, 0x3b, 0x15, 0x5, 0xd6, 0x1, 0x6f, 0x94, 0xf3, 0x3b, 0x15, 0x5, 0xd6, 0x1, 0x6f, 0x94, 0xf3, 0x3b, 0x15, 0x5, 0xd6, 0x1, 0x50, 0x4b, 0x1, 0x2, 0x3f, 0x0, 0xa, 0x0, 0x0, 0x0, 0x0, 0x0, 0x46, 0x3, 0x7d, 0x50, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xc, 0x0, 0x24, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x20, 0x0, 0x0, 0x0, 0xd1, 0x0, 0x0, 0x0, 0x73, 0x75, 0x62, 0x64, 0x69, 0x72, 0x2f, 0x78, 0x2e, 0x74, 0x78, 0x74, 0xa, 0x0, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x18, 0x0, 0x82, 0x86, 0x24, 0x36, 0x15, 0x5, 0xd6, 0x1, 0x82, 0x86, 0x24, 0x36, 0x15, 0x5, 0xd6, 0x1, 0x82, 0x86, 0x24, 0x36, 0x15, 0x5, 0xd6, 0x1, 0x50, 0x4b, 0x1, 0x2, 0x3f, 0x0, 0xa, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2f, 0x3, 0x7d, 0x50, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7, 0x0, 0x24, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x20, 0x0, 0x0, 0x0, 0xfb, 0x0, 0x0, 0x0, 0x78, 0x79, 0x7a, 0x2e, 0x74, 0x78, 0x74, 0xa, 0x0, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x18, 0x0, 0x2d, 0x8a, 0xaf, 0x1c, 0x15, 0x5, 0xd6, 0x1, 0x2d, 0x8a, 0xaf, 0x1c, 0x15, 0x5, 0xd6, 0x1, 0xed, 0xbc, 0x7e, 0x15, 0x15, 0x5, 0xd6, 0x1, 0x50, 0x4b, 0x5, 0x6, 0x0, 0x0, 0x0, 0x0, 0x7, 0x0, 0x7, 0x0, 0x8c, 0x2, 0x0, 0x0, 0x20, 0x1, 0x0, 0x0, 0x0, 0x0},
		[]string{
			"def.txt",
			"empty_dir/",
			"subdir/",
			"subdir/subdir2/",
			"subdir/subdir2/y.txt",
			"subdir/x.txt",
			"xyz.txt",
		},
	},
}

func TestUnarchiveDir(t *testing.T) {
	fs := afero.NewMemMapFs()
	for _, tc := range testcases {
		testUnarchiveDirFile(t, fs, tc)
	}
}

func testUnarchiveDirFile(t *testing.T, fs afero.Fs, tc testCaseUnarchiveDir) {
	srcFile := "input.zip"
	if err := afero.WriteFile(fs, srcFile, tc.data, 0644); err != nil {
		t.Errorf("expected nil, but %v", err)
		return
	}
	defer fs.Remove(srcFile)

	dstDir := "dstDir"
	if err := Unarchive(fs, srcFile, dstDir); err != nil {
		t.Errorf("%q: expected nil, but %v", srcFile, err)
		return
	}
	defer fs.RemoveAll(dstDir)

	files, err := aferoutil.ListFiles(fs, dstDir)
	if err != nil {
		t.Errorf("expected nil, but %v", err)
		return
	}

	for i, f := range tc.files {
		tc.files[i] = filepath.Join(dstDir, f)
	}

	sort.Strings(tc.files)
	sort.Strings(files)
	if !reflect.DeepEqual(tc.files, files) {
		t.Errorf("not equals, expected %v, but %v", tc.files, files)
		return
	}
}

func TestUnarchiveDirectoryAlreadyExists(t *testing.T) {
	fs := afero.NewMemMapFs()
	tc := testcases[0]

	srcFile := "input.zip"
	if err := afero.WriteFile(fs, srcFile, tc.data, 0644); err != nil {
		t.Errorf("expected nil, but %v", err)
		return
	}
	defer fs.Remove(srcFile)

	dstDir := filepath.Clean("dst/")
	if err := fs.MkdirAll(dstDir, 0666); err != nil {
		t.Fatalf("fail to MkdirAll(%q)", dstDir)
	}
	defer fs.RemoveAll(dstDir)

	err := Unarchive(fs, srcFile, dstDir)
	if err == nil {
		t.Error("expected error occured, but no error")
		return
	}
}

func TestEr(t *testing.T) {
	var (
		oldErr = errors.New("Old error")
		newErr = errors.New("New error")
	)

	testcases := []struct {
		init     error
		input    error
		expected error
	}{
		{nil, nil, nil},
		{nil, newErr, newErr},
		{oldErr, nil, oldErr},
		{oldErr, newErr, oldErr},
	}

	for _, tc := range testcases {
		err := tc.init
		f := func() error {
			return tc.input
		}
		er(f, &err)
		if err != tc.expected {
			t.Errorf("expected %v, but %v", tc.expected, err)
		}
	}
}
